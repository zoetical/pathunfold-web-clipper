### PathUnfold Web Clipper 浏览器插件完整技术设计
插件名为“PathUnfold Web Clipper”，是一个Chrome浏览器扩展（兼容Firefox），允许社群成员从网页剪藏文字、图片、视频、音频，并通过Circle Headless Member API发布到社区空间作为帖子。视频/音频内嵌通过帖子body中的单独链接段落（模拟“回车”）触发Circle的oEmbed机制（自动转换为可播放的<iframe>）。

设计基于Circle Headless Member API文档（基URL: https://app.circle.so/api/v1/headless/，认证用JWT access_token）。认证通过你的后端处理（成员只需输入email），前端不暴露任何Circle API token。插件全前端实现（JavaScript/HTML），后端需单独部署（e.g., Node.js）。

#### 1. 插件目标与功能
- **目标**：类似Obsidian Web Clipper，让Circle社群成员快速剪藏网页内容（文字、图片URL、视频/音频URL），一键发布为帖子，支持媒体嵌入。适合社区知识分享、内容 curation。
- **核心功能**：
  - 剪藏：捕获网页标题、选中文本、图片/媒体URL。
  - 编辑：弹出窗口显示剪藏内容，用户编辑标题/内容/空间ID。
  - 发布：格式化帖子body（HTML，支持<img>和oEmbed链接），用Member API创建帖子。
  - 认证：成员输入email，后端生成JWT access_token（1小时有效）。
  - 支持媒体：文字直接文本；图片用<img src="URL">；视频/音频用单独<p>URL</p>触发Circle oEmbed（e.g., YouTube、Vimeo、Spotify）。
- **限制**：当前用URL嵌入媒体（无需上传文件）；若需附件上传，可扩展attachments参数（Circle支持）。

#### 2. 技术栈
- **浏览器扩展框架**：Chrome Extension Manifest V3（最新标准，确保安全/性能）。
- **语言**：JavaScript（逻辑）、HTML/CSS（界面：弹出窗口、设置页）。
- **API集成**：
  - **Circle Headless Member API**：基URL https://app.circle.so/api/v1/headless/。
    - 认证：后端调用Auth API生成access_token（POST /auth_token）。
    - 帖子创建：POST /posts，参数：space_id (string, 空间ID)、name (string, 标题)、body (string, HTML内容)、post_type (string, "basic")。
    - body格式：HTML，支持oEmbed（视频链接自动嵌入）。
  - **工具**：Fetch API（HTTP请求）。
- **存储**：Chrome Storage API（保存email、access_token、spaceId）。
- **权限**：activeTab（访问网页）、storage（保存设置）。
- **后端**：Node.js/Express（或Vercel函数），处理认证（存储Headless Auth token，生成member JWT）。
- **开发工具**：VS Code、Chrome开发者工具。
- **测试/部署**：本地加载（Chrome://extensions/），发布Chrome Web Store。
- **不需要**：复杂框架（如React）；互联网安装（全本地+API）。
- **周期/成本**：2-4周（1开发者），预算1500-4000美元（含后端）。

#### 3. 架构设计
- **组件**：
  - **内容脚本 (content.js)**：注入网页，捕获选中内容/媒体。
  - **弹出窗口 (popup.html/js)**：用户界面，显示/编辑剪藏，触发发布。
  - **设置页 (options.html/js)**：输入email，调用后端认证。
  - **后台脚本 (background.js)**：处理API调用（发布帖子），因弹出窗口可能关闭。
- **数据流**：
  - 网页 → content.js 捕获数据 → popup.js 显示/格式化。
  - popup.js → background.js 发送帖子数据 → Circle API。
  - options.js → 后端/auth → 返回access_token → 存储。
- **认证流程**：
  1. 用户输入email。
  2. 插件POST到后端/auth（body: {email}）。
  3. 后端用Headless Auth token调用Circle /auth_token，获取access_token，返回给插件。
  4. 插件存储access_token，用于Member API请求。
- **媒体处理**：
  - 格式化body为HTML：文字用<p>；图片用<img>；视频/音频用<p>URL</p>（Circle oEmbed自动处理）。
  - 如果oEmbed失败，可可选调用oEmbed API生成<iframe>（e.g., https://www.youtube.com/oembed?url=...）。
- **错误处理**：token过期提示重新认证；网络错误显示消息。
- **安全**：access_token存储在chrome.storage（浏览器隔离）；后端安全存储Auth token（环境变量）。

#### 4. 用户流程
1. 安装插件（Chrome Web Store或本地加载）。
2. 右键插件图标 > 选项，输入email，点击“Authenticate”（后端生成token）。
3. 浏览网页，选中内容/媒体，点击插件图标。
4. 弹出窗口：自动填充标题/内容（含媒体），输入space_id，编辑后点击“Post to Circle”。
5. 插件格式化HTML body，用token发送到Member API /posts。
6. 成功：显示“Posted successfully”；失败：显示错误（e.g., “Token expired, re-authenticate”）。
7. token过期（1小时）：重新步骤2。

#### 5. 潜在挑战与解决方案
- **token管理**：过期后需重新认证。解决方案：后端支持refresh_token（若API提供），插件自动刷新。
- **媒体嵌入**：依赖Circle oEmbed。解决方案：测试后若不自动，插件加oEmbed fetch。
- **后端依赖**：需部署。解决方案：用Vercel免费部署Node.js。
- **权限/隐私**：插件只访问当前页。解决方案：最小权限声明。
- **扩展**：未来加空间列表（用GET /spaces端点）；文件上传（attachments）。

#### 6. 后端示例代码（Node.js/Express，部署到Vercel/Heroku）
创建一个server.js文件，设置环境变量CIRCLE_AUTH_TOKEN（你的Headless Auth token，从Circle后台生成）。
```javascript
const express = require('express');
const fetch = require('node-fetch');
const app = express();
app.use(express.json());

const CIRCLE_AUTH_TOKEN = process.env.CIRCLE_AUTH_TOKEN;  // 环境变量

app.post('/auth', async (req, res) => {
  const { email } = req.body;
  if (!email) return res.status(400).json({ error: 'Email required' });

  try {
    const response = await fetch('https://app.circle.so/api/v1/headless/auth_token', {  // Auth端点
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${CIRCLE_AUTH_TOKEN}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ email })
    });
    const data = await response.json();
    if (data.access_token) {
      res.json({ access_token: data.access_token });
    } else {
      res.status(400).json({ error: data.error || 'Failed to generate token' });
    }
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.listen(process.env.PORT || 3000, () => console.log('Server running'));
```
- 部署：上传到Vercel，设置环境变量。获取URL如https://your-backend.vercel.app/auth，替换插件代码中'https://your-backend.com/auth'。

#### 7. 插件所有代码文件
创建一个文件夹“pathunfold-web-clipper”，放入以下文件和你的图标（icon16.png、icon48.png、icon128.png）。在Chrome://extensions/加载测试。

**文件1: manifest.json**（配置文件）
```json
{
  "manifest_version": 3,
  "name": "PathUnfold Web Clipper",
  "version": "1.0",
  "description": "Clip web content (text, images, videos, audio) and post to Circle.so using Headless Member API",
  "icons": {
    "16": "icon16.png",
    "48": "icon48.png",
    "128": "icon128.png"
  },
  "permissions": ["activeTab", "storage"],
  "action": {
    "default_popup": "popup.html"
  },
  "options_ui": {
    "page": "options.html",
    "open_in_tab": false
  },
  "content_scripts": [
    {
      "matches": ["<all_urls>"],
      "js": ["content.js"]
    }
  ],
  "background": {
    "service_worker": "background.js"
  }
}
```

**文件2: content.js**（捕获网页内容）
```javascript
// 捕获选中内容和媒体
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === "getClipData") {
    const selectedText = window.getSelection().toString();
    const pageTitle = document.title;
    const pageUrl = window.location.href;

    let imageUrl = '';
    const selectedImg = document.querySelector('img:hover') || document.querySelector('img');
    if (selectedImg) imageUrl = selectedImg.src;

    let mediaUrl = '';
    const video = document.querySelector('video') || document.querySelector('iframe[src*="youtube"], iframe[src*="vimeo"]');
    if (video) mediaUrl = video.src || video.getAttribute('src');

    const audio = document.querySelector('audio');
    if (audio) mediaUrl = audio.src;

    sendResponse({
      title: pageTitle,
      content: selectedText || "No text selected",
      url: pageUrl,
      imageUrl,
      mediaUrl
    });
  }
  return true;
});
```

**文件3: popup.html**（弹出窗口界面）
```html
<!DOCTYPE html>
<html>
<head>
  <title>PathUnfold Web Clipper</title>
  <style>
    body { width: 300px; padding: 10px; font-family: Arial; }
    button { background: #007bff; color: white; padding: 5px; border: none; cursor: pointer; }
    button:hover { background: #0056b3; }
    input, textarea { width: 100%; margin: 5px 0; }
  </style>
</head>
<body>
  <h3>Clip to Circle</h3>
  <label>Title:</label>
  <input id="title" type="text"><br>
  <label>Content (HTML):</label>
  <textarea id="content" rows="5"></textarea><br>
  <label>Space ID:</label>
  <input id="spaceId" type="text" placeholder="Enter Circle Space ID"><br>
  <button id="postButton">Post to Circle</button>
  <div id="status"></div>
  <script src="popup.js"></script>
</body>
</html>
```

**文件4: popup.js**（弹出窗口逻辑）
```javascript
document.addEventListener('DOMContentLoaded', () => {
  chrome.tabs.query({active: true, currentWindow: true}, (tabs) => {
    chrome.tabs.sendMessage(tabs[0].id, {action: "getClipData"}, (response) => {
      document.getElementById('title').value = response.title;
      
      // 格式化为HTML body
      let bodyContent = `<p>${response.content}</p><p>Source: <a href="${response.url}">${response.url}</a></p>`;
      if (response.imageUrl) {
        bodyContent += `<p><img src="${response.imageUrl}" alt="Clipped Image" style="max-width:100%;"></p>`;
      }
      if (response.mediaUrl) {
        bodyContent += `<p>${response.mediaUrl}</p>`;  // 单独段落触发oEmbed
      }
      
      document.getElementById('content').value = bodyContent;
    });
  });

  chrome.storage.sync.get(['spaceId'], (data) => {
    if (data.spaceId) {
      document.getElementById('spaceId').value = data.spaceId;
    }
  });

  document.getElementById('postButton').addEventListener('click', () => {
    const title = document.getElementById('title').value;
    const content = document.getElementById('content').value;
    const spaceId = document.getElementById('spaceId').value;

    chrome.storage.sync.set({spaceId: spaceId});

    chrome.runtime.sendMessage({
      action: "postToCircle",
      data: { title, content, spaceId }
    }, (response) => {
      document.getElementById('status').textContent = response.message;
    });
  });
});
```

**文件5: options.html**（设置页界面）
```html
<!DOCTYPE html>
<html>
<head>
  <title>PathUnfold Web Clipper Settings</title>
  <style>
    body { padding: 10px; font-family: Arial; }
    input { width: 100%; margin: 5px 0; }
    button { background: #007bff; color: white; padding: 5px; border: none; cursor: pointer; }
    button:hover { background: #0056b3; }
  </style>
</head>
<body>
  <h3>Settings</h3>
  <label>Your Circle Email:</label>
  <input id="email" type="text" placeholder="user@example.com"><br>
  <button id="save">Authenticate</button>
  <div id="status"></div>
  <p>Note: Token expires in 1 hour; re-authenticate as needed.</p>
  <script src="options.js"></script>
</body>
</html>
```

**文件6: options.js**（设置页逻辑）
```javascript
document.addEventListener('DOMContentLoaded', () => {
  chrome.storage.sync.get(['email'], (data) => {
    document.getElementById('email').value = data.email || '';
  });

  document.getElementById('save').addEventListener('click', async () => {
    const email = document.getElementById('email').value;

    if (!email) {
      document.getElementById('status').textContent = 'Please enter a valid email.';
      return;
    }

    chrome.storage.sync.set({email});

    try {
      const response = await fetch('https://your-backend.com/auth', {  // 替换为你的后端URL
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ email })
      });
      const data = await response.json();
      if (data.access_token) {
        chrome.storage.sync.set({accessToken: data.access_token});
        document.getElementById('status').textContent = 'Authenticated successfully!';
      } else {
        document.getElementById('status').textContent = 'Error: ' + (data.error || 'Invalid response');
      }
    } catch (error) {
      document.getElementById('status').textContent = 'Network error: ' + error.message;
    }
  });
});
```

**文件7: background.js**（后台脚本）
```javascript
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request.action === "postToCircle") {
    chrome.storage.sync.get(['accessToken'], async (data) => {
      if (!data.accessToken) {
        sendResponse({message: "Please authenticate in settings."});
        return;
      }

      const postData = {
        space_id: request.data.spaceId,
        name: request.data.title,
        body: request.data.content,  // HTML with media
        post_type: "basic"
      };

      try {
        const response = await fetch('https://app.circle.so/api/v1/headless/posts', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${data.accessToken}`
          },
          body: JSON.stringify(postData)
        });

        if (response.ok) {
          sendResponse({message: "Posted successfully!"});
        } else {
          sendResponse({message: "Error: " + response.statusText + " (Check token or parameters)"});
        }
      } catch (error) {
        sendResponse({message: "Network error: " + error.message});
      }
    });
    return true;
  }
});
```

#### 8. 测试与发布
- **测试**：文件夹中放文件/图标，在Chrome加载。输入email认证，剪藏网页，发布（需有效space_id）。
- **发布**：上传到Chrome Web Store，添加描述/截图。
- **API验证**：开发者用Postman测试Member API，确保oEmbed工作（body中链接自动嵌入）。